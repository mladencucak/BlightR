---
title: "Weather forecast analysis"
author: "Mladen Cucak"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: word_document
fontsize: 10pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(dpi=300,fig.width=7)
```
 
```{r message=FALSE, warning=FALSE}
source(here::here("scr","lib",  "pkg.R"))
source(here::here("scr", "lib", "funs.R"))
```
## Intro
Weather data 
Weather observations were collated for ????5 Met Éireann synoptic weather stations in Ireland for the period from 2017 to 2019???. The historical weather data consisted of hourly observations air temperature (℃) and relative humidity (%) at 2m,
the total hourly precipitation (mm) and solar radiation (J/cm2). ????Solar radiation was converted to MJ/cm2 to allow the model run. 
 10 day weather forecast (???ECMWF model??) consisted of corresponding variables, with time series ending on 20 September to allow for ten day lag at the end of the month. This period was selected as it is representative for the duration blight season. ???missing dates The weather forecast data fot 3, 5 and 10 following days was deliverd in 1, 3 and 6 hour temporal resolution, respectively.  

*Different models/select single model or compare them*  
*Cube idea* 
information content:    
* Decision threshold (reducing causes higher risk, more savings and more uncertanty in forecast(?))  
* Lead time  
* Observed/forecasted variables (perhaps need more data)  
* Positive negative forecast  

## Intro  
Range of decision thresholds
```{r pic21, echo=FALSE, fig.cap="ddddd", out.width = '100%'}
knitr::include_graphics(here::here("out", "default", "model_eval.png"))
```  
```{r model_eval_facets, echo=FALSE, fig.cap="A caption", out.width = '100%'}
knitr::include_graphics(here::here("out", "default", "model_eval_facets.png"))
``` 
  
  
The data is consisted of model runs with observed and forecasted weather data.
```{r dataload,echo=FALSE,  out.width = '100%'}
load( file =here::here("out", "fore", "fore_model_out.Rdata"))

out_df <- 
  out_ls %>% 
  bind_rows() %>% 
  select(-id) %>% 
  unite("id", for_date, stna, remove = FALSE) %>% 
  group_by(id) %>% 
  mutate(day_step = doy - min(doy-1)) %>% 
  ungroup()
head(out_df)

```

```{r dataprep,echo=FALSE}

out_ls <- split(out_df, out_df$id)
head(out_ls[[1]])


fun_df <-  out_ls[[1]]
model <-  colnames(fun_df[, grepl("risk" , names(fun_df))])[1]

dd <- 
fun_df %>% 
  select(c(doy, set,id,short_date, model)) %>% 
  spread(set, risk_si)

dd <- 
  out_df %>% 
  select(c(doy, set,id,short_date, day_step, model)) %>% 
  spread(set, risk_si)  
# 
# out_df %>% 
#   select(c(doy, set,id,short_date, day_step, model)) %>% 
#   spread(set, risk_si) %>% 
#   group_by(day_step) %>% 
#   summarise( rmse = sqrt(mean(fore - obs)^2),
#              mse = mean(abs(fore - obs))) %>% 
#   ungroup() 
kable(dd[1:10,])
```

## Cases&controls

If the analysis is run for a specific decision threshold.  
The corresponding risk to desired threshold is found using linear interpolation between the two nearest thresholds. 

```{r pressure, echo=FALSE}
# load the evaluation data from calibrated model
# Add the uncertainty around the threshold ?? Taht woudl make it interesting?? 

load( file = here::here("out", "default", "model_eval.Rdata"))
load( file = here::here("out", "calib", "warning_thresholds_calib.Rdata"))
warn_t_df %>% round(2) %>% kable()
```

  
A single decision threshold is used throughout the analysis, 

```{r}
#decide on what is minimum accepted proportion of true predictions
prop_tpp <- 0.9

#pick the model
model <-  colnames(fun_df[, grepl("risk" , names(fun_df))])[1]

# find two nearest warning thresholds to the accepted decision threshold
closest_high <- sum(default_eval_lss[[1]][model]>prop_tpp)
closest_low <-which(default_eval_lss[[1]][model]<prop_tpp)[1]

tpp <- 
  default_eval_lss[[1]][model][closest_high:closest_low,] %>% unlist()
# Find the risk estimate for these two thresholds
risk <- 
  warn_t_df[default_eval_lss[[1]]["warning_thres"][closest_high:closest_low,] %>% unlist(),model] 
#estimate the risk for point prop_tpp
risk_thresh <- 
  predict(lm(risk ~ tpp), data.frame(tpp = prop_tpp))



```


```{r init_plot,  warning=FALSE}
#List of outputs per model
models <-  colnames(out_df[, grepl("risk" , names(out_df))])

# Plot obs vs pred scatterplts for each model faceted weather and day step
model <- models[7]
out_df %>% 
  select(c(set,for_date,stna, day_step, model)) %>% 
  spread(set, model) %>% 
  reshape2::melt( .,
                  id.vars = c("stna", "for_date", "day_step", "obs"),
                  measure.vars= c("fore", "fore_rhum", "fore_sol_rad", "fore_temp","obs", "obs_rhum", "obs_sol_rad", "obs_temp"),
                  variable.name = "set",
                  value.name = "pred",
                  factorsAsStrings  = FALSE
  ) %>% 
  filter(set != "obs") %>% 
  ggplot(aes(obs,pred, colour =stna))+
  geom_point(size= 0.5)+
  facet_wrap(set~day_step, ncol = 10)+
  theme_bw()+
  theme(legend.position = "top")+
  labs(colour= "Station", 
       title = "Combinations of outputs using forecasted versus observed weather data over lead time",
       subtitle = paste("Outputs for model", model),
       x = "Observed", y = "Predicted")+
  ggsave(filename = here::here("out", "fore", "fig", paste(model, "risk_si model out for all forecast versions vs lead time .png")), width = 13, height = 14)

```


```{r sec_init_plot, warning=FALSE}
#List of outputs per model
models <-  colnames(out_df[, grepl("risk" , names(out_df))])

# Plot obs vs pred scatterplts for each model faceted weather and day step
model <- models[1]
out_df %>% 
  select(c(set,for_date,stna, day_step, model)) %>% 
  spread(set, model) %>% 
  reshape2::melt( .,
                  id.vars = c("stna", "for_date", "day_step", "obs"),
                  measure.vars= c("fore", "fore_rhum", "fore_sol_rad", "fore_temp","obs", "obs_rhum", "obs_sol_rad", "obs_temp"),
                  variable.name = "set",
                  value.name = "pred",
                  factorsAsStrings  = FALSE
  ) %>% 
  filter(set != "obs") %>% 
  ggplot(aes(obs,pred, colour =stna))+
  geom_point(size= 0.5)+
  facet_wrap(set~day_step, ncol = 10)+
  theme_bw()+
  theme(legend.position = "top")+
  labs(colour= "Station", 
       title = "Combinations of outputs using forecasted versus observed weather data over lead time",
       subtitle = paste("Outputs for model", model),
       x = "Observed", y = "Predicted")+
  ggsave(filename = here::here("out", "fore", "fig", paste(model, "risk_si model out for all forecast versions vs lead time .png")), width = 13, height = 14)

```


```{r}
# Reshaping the data to set up columns for observed and forecasted values
dff <- 
out_df %>% 
  select(c(set,for_date,stna, day_step, models)) %>% 
  reshape2::melt( .,
                  id.vars = c( "set", "stna", "for_date", "day_step"),
                  measure.vars= models,
                  variable.name = "model",
                  value.name = "risk",
                  factorsAsStrings  = FALSE
  ) %>%
 spread(set, risk) %>% 
  reshape2::melt( .,
                  id.vars = c("stna", "for_date", "day_step", "model", "obs"),
                  measure.vars= c("fore", "fore_rhum", "fore_sol_rad", "fore_temp","obs", "obs_rhum", "obs_sol_rad", "obs_temp"),
                  variable.name = "set",
                  value.name = "pred",
                  factorsAsStrings  = FALSE
  ) %>% 
  filter(set != "obs")

head(dff)
```
  
  The model output data is turned into binary values. Here we take the model output data and convert it to 1/0 values for each corresponding warning threshold (first loop) for each model(2nd loop - the within the 1st loop). 

```{r}
wtls <- list()
out_ls <- split(dff, dff$model) 
names(out_ls) <-
  sapply(out_ls, function(x) unique(x$model))


for(i in seq_along(warn_t_df$warn_thresh)){
  loop_list <-  list()
  for(y in names(out_ls)){
    # Find threshold in (lookup table) with all decision thresholds. 
     threshold <- warn_t_df[i, y]
     
     loop_list[[y]] <-
       mutate(out_ls[[y]], warn_thresh = warn_t_df$warn_thresh[[i]]) %>%  # Add a column for warning threshold
       mutate(obs = ifelse(obs >= threshold, 1, 0)) %>%      #
       mutate(pred = ifelse(pred >= threshold[1] , 1, 0))
     rm(threshold)
  }
  wtls [[i]] <- loop_list %>% bind_rows()
  rm(loop_list)
}


dff <- 
wtls %>% 
  bind_rows() %>% 
  select(set, model, warn_thresh, day_step, stna, for_date, obs, pred)

 
dff %>%  head()
```

Generate frequency tables. *This might be very slow and probably should not be run on computers with RAM < 8GB* 

```{r}
#tab <-
#  with(tab, table(set, model, warn_thresh, day_step, obs, pred))
```

